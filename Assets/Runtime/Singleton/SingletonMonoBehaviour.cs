using System.Collections.Generic;
using UnityEngine;

namespace Hooran._Packages.Singleton
{
    /// <summary>
    /// Inherit from this base class to create a SingletonMonoBehaviour.
    /// e.g. public class MyClassName : SingletonMonoBehaviour<MyClassName> {}
    /// </summary>
    [DisallowMultipleComponent]
    public abstract class SingletonMonoBehaviour<T> : MonoBehaviour where T : SingletonMonoBehaviour<T>
    {
        #region Configuration

        /// <summary>
        /// Should we wait with finding the correct instance until a script tries to access it? If set to false,
        /// we load the instance on Awake.
        /// </summary>
        public static bool LoadOnDemand = false;

        /// <summary>
        /// If true, we also consider inactive elements in the scene when we search for an instance.
        /// </summary>
        protected static bool ConsiderInactiveInstances = false;

        /// <summary>
        /// If true, we do not destroy the instance on scene loads.
        /// </summary>
        protected static bool PersistOnSceneLoad = true;

        #endregion

        #region Internal

        private static T _instance = null;

        private static readonly object InstanceLock = new object();

        private static bool _instantiated = false;

        private static int _preferredInstanceId = -1;

        private static bool _instanceDestroyed = false;

        #endregion

        /// <summary>
        /// The current instance of the singleton class.
        /// </summary>
        public static T Instance
        {
            get
            {
                if (Application.isEditor && !Application.isPlaying)
                    return null;

                lock (InstanceLock)
                {
                    if (_instantiated)
                    {
                        // We have an instance...
                        return _instance;
                    }
                    else if (!_instanceDestroyed)
                    {
                        // We have no instance but we can initialize one...
                        InitializeInstance();
                        _instance.OnCreateSingleton();
                        return _instance;
                    }
                    else
                    {
                        // We do not have an instance and we are not allowed to create one...
                        return null;
                    }
                }
            }
            private set
            {
                _instance = value;

                if (PersistOnSceneLoad)
                {
                    // Prepare the persistence.
                    if (_instance.transform.parent != null)
                    {
                        _instance.transform.SetParent(null);
                    }

                    // Make the instance persistent.
                    DontDestroyOnLoad(_instance.gameObject);
                }

                _instantiated = true;
            }
        }

        private static void InitializeInstance()
        {
            // Find all [active / active and inactive] instances in the scene.
            var objects = ConsiderInactiveInstances
                ? Resources.FindObjectsOfTypeAll(typeof(T))
                : FindObjectsOfType(typeof(T));

            if (objects == null || objects.Length < 1)
            {
                Instance = new GameObject().AddComponent<T>();
                Instance.name = $"{typeof(T)} – Autogenerated Singleton";
            }
            else if (objects.Length >= 1)
            {
                // There is at least one instance in the scene...

                // ... so we always take the preferred instance or the first one:
                if (_preferredInstanceId != -1)
                {
                    for (var i = 0; i < objects.Length; i++)
                    {
                        if ((objects[i] as T).GetInstanceID() == _preferredInstanceId)
                        {
                            Instance = objects[i] as T;
                        }
                    }
                }
                else
                {
                    Instance = objects[0] as T;
                }
            }
        }

        /// <summary>
        /// Destroy an instance.
        /// </summary>
        /// <param name="instance">Object that should be destroyed</param>
        private static void DestroyInstance(Object instance)
        {
            // Check if it is already deleted. (If true, the object is not null but == works because of
            // unity's overload of the operator.)
            if (!instance)
            {
                Destroy(instance);
            }
        }

        // Virtual method that can be overridden in derived classes to handle additional initialization
        protected virtual void OnCreateSingleton()
        {
        }

        // Virtual method that can be overridden in derived classes to handle additional cleanup
        protected virtual void OnDestroySingleton()
        {
        }

        protected virtual void Awake()
        {
            if (!LoadOnDemand)
            {
                lock (InstanceLock)
                {
                    if (!_instantiated)
                    {
                        // This is the current instance. We set the preferred instance to the id of this and trigger
                        // the default initialize instance behavior so we can make sure that every scenario actual
                        // executes the same code.
                        _preferredInstanceId = GetInstanceID();
                    }
                    else
                    {
                        if (_instance != null)
                        {
                            DestroyInstance(this);
                        }
                    }
                }
            }
        }

        protected virtual void OnDestroy()
        {
            if (_instantiated && GetInstanceID() == _instance.GetInstanceID())
            {
                // We are destroying the current instance...
                // ... this should only be the case on application quit.
                // Prevent recreations.
                _instanceDestroyed = true;
                OnDestroySingleton();
            }
        }
    }
}